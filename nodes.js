// Get current time and 24h ago cutoff
const now = new Date();
const cutoff = new Date(now.getTime() - 24 * 60 * 60 * 1000);

const filtered = $input.all().filter(item => {
  const createdAt = item.json.tweet_created_at;
  if (!createdAt) return false;

  // Parse date
  const ts = new Date(createdAt);
  if (isNaN(ts.getTime())) return false;

  // Keep only tweets newer than cutoff
  return ts >= cutoff;
});

return filtered;

//Node 2:

const texts = $input.all().map(i => {
    const t = i.json.tweet_text || '';
    const h = i.json.user_handle || '';
    const u = i.json.tweet_url || '';
    const ts = i.json.tweet_created_at || '';
    return `@${h} | ${ts}\n${t}\n${u}`;
  });
  
  return [{
    json: {
      allTweets: texts.join("\n\n---\n\n"),  // separator
      count: texts.length
    }
  }];

//Node 3:
/**
 * n8n Function/Code node
 * Input: array of items with item.json like:
 *   { row_number, index, message, logprobs, finish_reason }
 * Output: single item with parsed message from the last row.
 */

// ---------- helpers ----------
function safeParseJSON(input) {
    try { return { ok: true, value: JSON.parse(input) }; }
    catch (err) { return { ok: false, error: err }; }
  }
  
  function trimToBalancedJSON(str) {
    let depth = 0;
    let lastGood = -1;
    let inStr = false;
    let esc = false;
    for (let i = 0; i < str.length; i++) {
      const ch = str[i];
  
      // respect strings so braces inside strings don't affect depth
      if (inStr) {
        if (!esc && ch === '\\') { esc = true; continue; }
        if (!esc && ch === '"') inStr = false;
        esc = false;
        continue;
      } else if (ch === '"') {
        inStr = true;
        continue;
      }
  
      if (ch === '{') depth++;
      else if (ch === '}') {
        depth--;
        if (depth === 0) lastGood = i;
        if (depth < 0) break;
      }
    }
    return lastGood >= 0 ? str.slice(0, lastGood + 1) : str;
  }
  
  function extractMessageFromRow(row) {
    const notes = [];
    const raw = row.message ?? '';
  
    // parse outer message
    let outer = safeParseJSON(raw);
    if (!outer.ok) {
      const trimmed = trimToBalancedJSON(raw);
      if (trimmed !== raw) {
        notes.push('Trimmed outer message to balanced JSON.');
        outer = safeParseJSON(trimmed);
      }
    }
    if (!outer.ok || typeof outer.value !== 'object') {
      return {
        row_number: row.row_number ?? null,
        role: null,
        content: null,
        raw,
        notes: ['Failed to parse outer message JSON.'].concat(notes),
      };
    }
  
    const role = outer.value.role ?? null;
    let content = outer.value.content ?? null;
  
    // inner content may be JSON-as-string
    if (typeof content === 'string') {
      let inner = safeParseJSON(content);
      if (!inner.ok) {
        const trimmedInner = trimToBalancedJSON(content);
        if (trimmedInner !== content) {
          notes.push('Trimmed inner content to balanced JSON.');
          inner = safeParseJSON(trimmedInner);
        }
      }
      if (inner.ok) content = inner.value;
      else notes.push('Inner content could not be parsed; leaving as string.');
    }
  
    return {
      row_number: row.row_number ?? null,
      role,
      content,
      raw,
      notes,
    };
  }
  
  // ---------- main ----------
  const rows = items.map(i => i.json);
  
  // Choose the last row by highest row_number if available, else last element
  let lastRow;
  const haveRowNums = rows.every(r => typeof r.row_number === 'number');
  if (haveRowNums && rows.length) {
    lastRow = rows.reduce((a, b) => (a.row_number > b.row_number ? a : b));
  } else {
    lastRow = rows[rows.length - 1];
  }
  
  const parsed = extractMessageFromRow(lastRow);
  
  // Return a single item
  return [
    {
      json: parsed
    }
  ];

 // Node 4:
 /**
 * n8n Code node (v2) — JavaScript
 * Input: items[].json with either:
 *  - { row_number, content: {...} }  (preferred), or
 *  - { row_number, message: "<json string>" } (fallback)
 * Output: [{ json: { subject, html, text } }]
 */

// ---------- helpers ----------
function esc(s) {
    return String(s ?? "")
      .replace(/&/g, "&amp;").replace(/</g, "&lt;")
      .replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  }
  function has(arr) { return Array.isArray(arr) && arr.length > 0; }
  
  function buildEmailHTML(content, options = {}) {
    const {
      title = "Daily Market Brief",
      date = new Date().toLocaleDateString("en-US", { year: "numeric", month: "long", day: "numeric" }),
      brandColor = "#0d1117",
      accentColor = "#2f81f7",
      footerNote = "Generated by your n8n automation",
    } = options;
  
    const sectionHeading = (txt) => `
      <tr>
        <td style="padding:18px 20px 8px 20px;">
          <h2 style="margin:0;font-size:18px;line-height:1.3;font-weight:700;color:${brandColor};">${esc(txt)}</h2>
        </td>
      </tr>`;
  
    const badge = (label) => `
      <span style="display:inline-block;padding:3px 8px;border:1px solid #d0d7de;border-radius:999px;font-size:12px;line-height:1.2;margin-right:6px;">
        ${esc(label)}
      </span>`;
  
    const renderSummary = () => (!content?.summary ? "" : `
      ${sectionHeading("Summary")}
      <tr>
        <td style="padding:8px 20px 16px 20px;color:#24292f;font-size:14px;line-height:1.6;">
          ${esc(content.summary)}
        </td>
      </tr>`);
  
    const renderInsights = () => (!has(content?.insights) ? "" : `
      ${sectionHeading("Insights")}
      <tr>
        <td style="padding:6px 12px 2px 12px;">
          <table role="presentation" width="100%" cellpadding="0" cellspacing="0" border="0" style="border-collapse:collapse;">
            <tbody>
              ${content.insights.map(it => `
                <tr>
                  <td style="padding:10px;border-bottom:1px solid #eaeef2;">
                    <div style="font-size:14px;">
                      <strong style="background:${accentColor};color:#fff;border-radius:6px;padding:2px 6px;margin-right:8px;display:inline-block;">
                        ${esc(it.ticker || "")}
                      </strong>
                      <span style="color:#24292f;">${esc(it.bullet || "")}</span>
                    </div>
                    <div style="margin-top:6px;font-size:12px;color:#57606a;">
                      ${it.horizon ? badge(`Horizon: ${it.horizon}`) : ""}
                      ${it.conviction ? badge(`Conviction: ${it.conviction}`) : ""}
                    </div>
                    ${it.recommendation ? `
                      <div style="margin-top:8px;font-size:13px;color:#24292f;">
                        <em>${esc(it.recommendation)}</em>
                      </div>` : ""}
                  </td>
                </tr>
              `).join("")}
            </tbody>
          </table>
        </td>
      </tr>`);
  
    const renderWatchlist = () => (!has(content?.watchlist) ? "" : `
      ${sectionHeading("Watchlist")}
      <tr>
        <td style="padding:6px 12px 2px 12px;">
          <table role="presentation" width="100%" cellpadding="0" cellspacing="0" border="0" style="border-collapse:collapse;">
            <tbody>
              ${content.watchlist.map(w => `
                <tr>
                  <td style="padding:10px;border-bottom:1px solid #eaeef2;">
                    <div style="font-size:14px;">
                      <strong style="background:#eaeef2;color:#24292f;border-radius:6px;padding:2px 6px;margin-right:8px;display:inline-block;">
                        ${esc(w.ticker || "")}
                      </strong>
                      <span style="color:#24292f;">${esc(w.why || "")}</span>
                    </div>
                    <div style="margin-top:6px;font-size:12px;color:#57606a;">
                      ${w.horizon ? badge(`Horizon: ${w.horizon}`) : ""}
                    </div>
                    ${w.recommendation ? `
                      <div style="margin-top:8px;font-size:13px;color:#24292f;">
                        <em>${esc(w.recommendation)}</em>
                      </div>` : ""}
                  </td>
                </tr>
              `).join("")}
            </tbody>
          </table>
        </td>
      </tr>`);
  
    const renderSources = () => (!has(content?.sources) ? "" : `
      ${sectionHeading("Sources")}
      <tr>
        <td style="padding:6px 20px 16px 20px;">
          <ul style="margin:0;padding-left:18px;color:#24292f;font-size:13px;line-height:1.6;">
            ${content.sources.map(s => `
              <li style="margin-bottom:6px;">
                ${s.note ? `<span>${esc(s.note)} — </span>` : ""}
                <a href="${esc(s.url || "#")}" style="color:${accentColor};text-decoration:none;">${esc(s.url)}</a>
              </li>
            `).join("")}
          </ul>
        </td>
      </tr>`);
  
    const html = `
    <!doctype html>
    <html>
    <head>
      <meta name="viewport" content="width=device-width, initial-scale=1"/>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      <title>${esc(title)}</title>
    </head>
    <body style="margin:0;padding:0;background:#f6f8fa;">
      <table role="presentation" cellpadding="0" cellspacing="0" border="0" width="100%" style="background:#f6f8fa;">
        <tr>
          <td style="padding:20px 12px;">
            <table role="presentation" cellpadding="0" cellspacing="0" border="0" align="center" width="100%" style="max-width:600px;background:#ffffff;border:1px solid #eaeef2;border-radius:10px;overflow:hidden;">
              <tr>
                <td style="background:${brandColor};padding:18px 20px;">
                  <h1 style="margin:0;font-size:20px;line-height:1.2;color:#ffffff;">${esc(title)}</h1>
                  <div style="margin-top:4px;font-size:12px;color:#c9d1d9;">${esc(date)}</div>
                </td>
              </tr>
  
              ${renderSummary()}
              ${renderInsights()}
              ${renderWatchlist()}
              ${renderSources()}
  
              <tr>
                <td style="padding:16px 20px;background:#fafbfc;border-top:1px solid #eaeef2;color:#57606a;font-size:12px;">
                  ${esc(footerNote)}
                </td>
              </tr>
            </table>
  
            <div style="max-width:600px;margin:10px auto 0 auto;font-size:11px;color:#6e7781;text-align:center;">
              You're receiving this because you subscribed to daily market updates.
            </div>
          </td>
        </tr>
      </table>
    </body>
    </html>`.trim();
  
    const text = [
      `${title} — ${date}`,
      "",
      content.summary ? `Summary:\n${content.summary}\n` : "",
      has(content.insights) ? `Insights:\n${content.insights.map(i =>
        `- ${i.ticker}: ${i.bullet} [Horizon: ${i.horizon || "-"}, Conviction: ${i.conviction || "-"}]\n  Recommendation: ${i.recommendation || "-"}`
      ).join("\n")}\n` : "",
      has(content.watchlist) ? `Watchlist:\n${content.watchlist.map(w =>
        `- ${w.ticker}: ${w.why} [Horizon: ${w.horizon || "-"}]\n  Recommendation: ${w.recommendation || "-"}`
      ).join("\n")}\n` : "",
      has(content.sources) ? `Sources:\n${content.sources.map(s => `- ${s.note || ""} ${s.url || ""}`).join("\n")}` : "",
    ].join("\n");
  
    const subject = `Market Brief — ${date}`;
    return { subject, html, text };
  }
  
  // ---------- MAIN ----------
  if (!Array.isArray(items) || items.length === 0) {
    return [{ json: { error: "No input items" } }];
  }
  
  // pick last by row_number (fallback: last element)
  const rows = items.map(i => i.json || {});
  const haveRowNums = rows.every(r => typeof r.row_number === 'number');
  const lastRow = haveRowNums
    ? rows.reduce((a, b) => (a.row_number > b.row_number ? a : b))
    : rows[rows.length - 1];
  
  // prefer parsed content; fallback to raw/message if needed
  let content = lastRow.content;
  if (!content && typeof lastRow.message === 'string') {
    try {
      const outer = JSON.parse(lastRow.message);
      content = typeof outer?.content === 'string' ? JSON.parse(outer.content) : outer.content;
    } catch (e) {
      return [{ json: { error: "Failed to parse content from message", details: String(e) } }];
    }
  }
  
  if (!content || typeof content !== 'object') {
    return [{ json: { error: "Missing or invalid content object on last row" } }];
  }
  
  const { subject, html, text } = buildEmailHTML(content, {
    title: "Aarush's Daily Market Brief",
    brandColor: "#111827",
    accentColor: "#2563eb",
    footerNote: "Built with n8n + OpenAI",
  });
  
  // Extract date in YYYY-MM-DD format
  const dateObj = new Date();
  const dateISO = dateObj.toISOString().split('T')[0]; // "2025-10-12"
  
  // ✅ Return exactly an array of items with all required fields for the website
  return [{
    json: {
      id: dateISO,           // for hash routing (#2025-10-12)
      date: dateISO,         // for sorting and display
      subject,               // "Market Brief — October 12, 2025"
      json: content,         // structured content (summary, insights, watchlist, sources)
      html,                  // keep for email
      text                   // keep for email plaintext
    }
  }];


// ============================================================================
// NODE 5: HTTP Request - GET Current briefs.json from GitHub
// ============================================================================
// Node Type: HTTP Request
// Method: GET
// URL: https://api.github.com/repos/aaruvan/aaruvan.github.io/contents/public/briefs.json
// Authentication: Generic Credential Type
//   - Credential Type: Header Auth
//   - Name: Authorization
//   - Value: token YOUR_GITHUB_PAT_HERE
// 
// Response Format: JSON
// 
// This node fetches the current briefs.json file from GitHub.
// GitHub returns:
// {
//   "content": "base64-encoded-json",
//   "sha": "file-version-hash"
// }


// ============================================================================
// NODE 6: Code - Parse, Append, and Prepare Update
// ============================================================================
/**
 * IMPORTANT: This node needs TWO inputs!
 * Input 1 (Node 5): GitHub GET response (HTTP Request node)
 * Input 2 (Node 4): New brief to add (formatter node)
 * 
 * To connect multiple inputs:
 * 1. Connect Node 5 to this node normally
 * 2. Hold SHIFT and drag from Node 4 to this node
 */

// Get all items from both inputs
const allItems = $input.all();

// Debug: Log what we received (will show in n8n execution log)
console.log('Total items received:', allItems.length);
allItems.forEach((item, idx) => {
  console.log(`Item ${idx} keys:`, Object.keys(item.json).join(', '));
});

// Separate items by source
let githubData = null;
let newBrief = null;

// Find the GitHub response and new brief
for (const item of allItems) {
  const data = item.json;
  
  // GitHub API response check (look for distinctive GitHub fields)
  if (data.sha && data.content && data.path && data.type === 'file') {
    console.log('Found GitHub response!');
    githubData = data;
  } 
  // New brief check (look for our brief structure)
  else if (data.id && data.date && data.subject && data.json) {
    console.log('Found new brief!');
    newBrief = data;
  }
}

// Validate we have both inputs
if (!githubData) {
  console.error('Could not find GitHub data. Items:', JSON.stringify(allItems.map(i => Object.keys(i.json)), null, 2));
  throw new Error('GitHub API response not found. Make sure Node 5 (HTTP GET) is connected.');
}
if (!newBrief) {
  console.error('Could not find new brief. Items:', JSON.stringify(allItems.map(i => Object.keys(i.json)), null, 2));
  throw new Error('New brief not found. Make sure Node 4 (formatter) is connected.');
}

// Decode base64 content from GitHub
const base64Content = githubData.content;
const decodedContent = Buffer.from(base64Content, 'base64').toString('utf-8');

// Parse existing briefs
let briefsArray = [];
try {
  briefsArray = JSON.parse(decodedContent);
  if (!Array.isArray(briefsArray)) {
    briefsArray = [];
  }
} catch (e) {
  // If file doesn't exist or is invalid, start fresh
  briefsArray = [];
}

// Check if this date already exists (prevent duplicates)
const existingIndex = briefsArray.findIndex(b => b.id === newBrief.id);
if (existingIndex >= 0) {
  // Update existing entry
  briefsArray[existingIndex] = newBrief;
} else {
  // Add new entry at the beginning (newest first)
  briefsArray.unshift(newBrief);
}

// Limit to last 30 briefs (optional, keeps file size manageable)
if (briefsArray.length > 30) {
  briefsArray = briefsArray.slice(0, 30);
}

// Convert back to JSON string (pretty print for readability)
const updatedJsonString = JSON.stringify(briefsArray, null, 2);

// Encode to base64 for GitHub API
const updatedBase64 = Buffer.from(updatedJsonString, 'utf-8').toString('base64');

// Return data needed for PUT request
return [{
  json: {
    content: updatedBase64,
    sha: githubData.sha,  // Required by GitHub API to update file
    message: `Update daily brief for ${newBrief.date}`,
    briefCount: briefsArray.length,
    addedBrief: newBrief.id  // For debugging
  }
}];


// ============================================================================
// NODE 7: HTTP Request - PUT Updated briefs.json to GitHub
// ============================================================================
// Node Type: HTTP Request
// Method: PUT
// URL: https://api.github.com/repos/aaruvan/aaruvan.github.io/contents/public/briefs.json
// Authentication: Generic Credential Type
//   - Credential Type: Header Auth
//   - Name: Authorization
//   - Value: token YOUR_GITHUB_PAT_HERE
// 
// Body: JSON
// {
//   "message": "{{ $json.message }}",
//   "content": "{{ $json.content }}",
//   "sha": "{{ $json.sha }}"
// }
// 
// Response Format: JSON
// 
// This updates the file on GitHub. The website will fetch the updated file
// on the next page load - no rebuild needed!


// ============================================================================
// WORKFLOW CONNECTION DIAGRAM
// ============================================================================
/*

Node 4 (Format Brief)
    ↓
    ├──→ Email Node (send email)
    │
    └──→ Node 5 (GET briefs.json) ──→ Node 6 (Merge & Prepare) ──→ Node 7 (PUT to GitHub)
                                            ↑
                                            │
                                    (Also receives Node 4 output)

*/


// ============================================================================
// IMPORTANT NOTES FOR SETUP
// ============================================================================
/*

1. GITHUB PERSONAL ACCESS TOKEN
   - Go to: https://github.com/settings/tokens
   - Generate new token (classic)
   - Required scopes: 'repo' (full control of private repositories)
   - Copy token and save it securely
   - Use format: token ghp_YOUR_TOKEN_HERE

2. N8N NODE CONFIGURATION

   Node 6 needs TWO inputs:
   - Input 1: Node 5 (GitHub GET response)
   - Input 2: Node 4 (New brief to add)
   
   To connect multiple inputs in n8n:
   a) Create Node 6 (Code node)
   b) Connect Node 5 output to Node 6
   c) Hold Shift and drag from Node 4 to Node 6 for second input

3. FILE PATH
   - Must be: public/briefs.json
   - NOT: briefs.json or /briefs.json
   - The path is relative to repo root

4. TESTING
   - Run workflow manually first
   - Check: https://github.com/aaruvan/aaruvan.github.io/blob/main/public/briefs.json
   - Visit: https://aaruvan.github.io/ (wait 30 seconds for cache refresh)

5. ERROR HANDLING
   - If SHA mismatch error: Someone else updated the file, retry
   - If 404 error: File path is wrong, check 'public/briefs.json'
   - If 401 error: Token is invalid or missing 'repo' scope

*/
